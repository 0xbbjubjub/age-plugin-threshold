# Age Threshold Encryption

https://bbjubjub.fr/age-threshold/v0

v0.1, no compatibility guarantees

## File keys
For each age threshold-encrypted file, a unique random 128-bit symmetric key. This is identical to the file key in age v1.

## Secret sharing
Secret sharing is performed on the file key.
First, the file key is converted to a scalar by interpreting it as a little-endian integer.
We then work in the field of order `l = 2^252 + 27742317777372353535851937790883648493` following [Ristretto255.](https://www.ietf.org/archive/id/draft-irtf-cfrg-ristretto255-00.html#name-ristretto255)
A polynomial S(x) of degree `threshold - 1` is generated, with the constant term being the file key scalar.
A second entirely random polynomial T(x) of the same degree is also generated.

We define the generators G and H as TODO.
Commitment values are generated by computing `C_i = s_i · G + t_i · H`, where `s_i` and `t_i` are the coefficients of S(x) and T(x) respectively.

Shares are generated by evaluating S(x) and T(x) at `x = 1, 2, ..., n`, where `n` is the number of recipients.
This results in two scalars `s` and `t`.
They are serialized for encryption as 32-byte little-endian integers, s first.
The index is not serialized.

### Share verification
Encrypted shares (s,t) are verified by checking that `s · G + t · H` is equal to `Σ C_i · xⁱ`.
This follows [Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing §4.2.](https://link.springer.com/chapter/10.1007/3-540-46766-1_9)
The rest of this document will outline when verification should be performed.

### Secret reconstruction
The file key is reconstructed by interpolating the `s` part of enough shares.
Only the constant term of the polynomial is needed, so the Lagrange interpolation formula can be used.

### Encrypted shares
Each share is encrypted with a dedicated file key.
Shares are encrypted by encrypting the serialized form is the file key encrypted with ChaCha20-Poly1305, using the file key as the key and an all-zero IV.

## File format
Following [the age v1 file format](https://age-encryption.org/v1), the threshold file format is a concatenation of a text header and a binary payload.

### Header
The header wraps shares of the file key for one or more recipients, so that it can be recovered by a threshold of them.
It starts with the string `bbjubjub.fr/age-threshold/v0` on a line by itself, continues with age stanzas, and ends with the HMAC line.

#### Age stanzas
Stanzas follow the [age v1 stanza format](https://age-encryption.org/v1#recipient-stanza).

The first stanza must have the tag `threshold`, the threshold in decimal as the only argument, and an empty body.

The second stanza has tag `commitments`. Its arguments are the commitment values `C_i` in base64, serialized in compressed form.

The third stanza must be a share stanza:
its tag is `share`, 
its argument is the share index in decimal,
and its body is the encrypted share.
Following, one or more recipient stanzas must be present.
They wrap the share file key.
The pattern repeats for each threshold recipient.

#### HMAC line
The HMAC line starts with `---` and marks the end of the header.
TODO

### Payload
As in age v1, 
the binary payload encrypts the input.
Refer to [the age v1 payload specification](https://age-encryption.org/v1#payload).

## ASCII Armor
TODO
